import {
  GoogleGenAI,
  Modality,
} from '@google/genai';

// Lazy initialization to avoid crash on module load
let ai: GoogleGenAI | null = null;

function getEnvList(name: string, fallback: string[]): string[] {
  const raw = (import.meta as any).env?.[name] as string | undefined;
  if (!raw) {
    return fallback;
  }

  return raw
    .split(',')
    .map(model => model.trim())
    .filter(Boolean);
}

function getAI(): GoogleGenAI {
  if (!ai) {
    const apiKey = (import.meta as any).env?.VITE_GEMINI_API_KEY || '';
    console.log('üîë API Key check:', apiKey ? '‚úÖ Loaded' : '‚ùå Missing');
    console.log(
      'üîë API Key preview:',
      apiKey ? apiKey.substring(0, 20) + '...' : 'NONE'
    );
    if (!apiKey) {
      throw new Error(
        'VITE_GEMINI_API_KEY environment variable is not set. Please check your .env file.'
      );
    }
    console.log('üöÄ Initializing GoogleGenAI...');
    ai = new GoogleGenAI({ apiKey });
    console.log('‚úÖ GoogleGenAI initialized successfully');
  }
  return ai;
}

export async function transformImage(
  images: { data: string; mimeType: string }[],
  prompt: string
): Promise<string> {
  console.log('üé® Starting image transformation...');
  console.log('üìù Prompt:', prompt.substring(0, 50) + '...');
  console.log('üì∏ Images count:', images.length);
  console.log('üì∏ First image MIME:', images[0]?.mimeType);
  console.log('üì∏ First image data length:', images[0]?.data?.length);

  const imageModels = getEnvList('VITE_GEMINI_IMAGE_MODELS', [
    'gemini-2.5-pro',
    'gemini-2.0-flash-exp',
  ]);
  console.log('üß† Image model candidates:', imageModels);

  const imageParts = images.map(image => ({
    inlineData: {
      data: image.data,
      mimeType: image.mimeType,
    },
  }));

  const textPart = {
    text: `IMPORTANT: Keep the original person or animal completely realistic and recognizable. Do NOT transform them into the character. Instead, dress them in a Halloween costume that matches this description: ${prompt}. The person/animal should look exactly like themselves, just wearing the costume. The final image must be hyper-realistic, resembling a high-resolution photograph with natural lighting, detailed textures, and lifelike features. The original face, body, and features must remain clearly visible and unchanged - only add costume elements like clothing, accessories, makeup, and props. Avoid any cartoonish, illustrative, or morphing effects.`,
  };

  console.log('üì° Sending request to Gemini API...');
  console.log('üîë API Key loaded:', getAI() ? 'YES' : 'NO');

  let lastError: unknown = null;

  for (const model of imageModels) {
    console.log(`üß™ Attempting image model: ${model}`);

    try {
      const response = await getAI().models.generateContent({
        model,
        contents: [
          {
            parts: [...imageParts, textPart],
          },
        ],
        config: {
          responseModalities: [Modality.IMAGE, Modality.TEXT],
        },
      });

      console.log('‚úÖ Received response from Gemini API');
      console.log(
        'üì¶ Response structure:',
        JSON.stringify(response, null, 2).substring(0, 500)
      );

      if (!response) {
        throw new Error('No response received from API');
      }

      if (!response.candidates || response.candidates.length === 0) {
        throw new Error('No candidates in API response');
      }

      if (!response.candidates[0]?.content?.parts) {
        throw new Error('No parts in API response content');
      }

      console.log(
        'üì¶ Found',
        response.candidates[0].content.parts.length,
        'parts'
      );

      for (const part of response.candidates[0].content.parts) {
        console.log('üîç Checking part:', Object.keys(part));
        if (part.inlineData) {
          const base64ImageBytes: string = part.inlineData.data;
          const mimeType = part.inlineData.mimeType;
          console.log('üñºÔ∏è Image generated successfully!');
          return `data:${mimeType};base64,${base64ImageBytes}`;
        }
      }

      const textResponse = response.text;
      if (textResponse) {
        throw new Error(`Model could not generate image: ${textResponse}`);
      }

      throw new Error('No image was generated by the model.');
    } catch (error) {
      lastError = error;
      console.error(`‚ùå Model ${model} failed:`, error);
    }
  }

  console.error('‚ùå All image models failed');
  throw lastError instanceof Error
    ? lastError
    : new Error('All image models failed.');
}

export async function generateVideoFromImage(
  base64ImageData: string,
  mimeType: string,
  prompt: string
): Promise<string> {
  console.log('üé¨ Starting video generation...');
  console.log('üìù Video prompt:', prompt.substring(0, 50) + '...');

  const videoModels = getEnvList('VITE_GEMINI_VIDEO_MODELS', [
    'veo-2.0-generate-001',
    'veo-1.5-lite-001',
  ]);
  console.log('üé• Video model candidates:', videoModels);

  let lastError: unknown = null;

  for (const model of videoModels) {
    console.log(`üß™ Attempting video model: ${model}`);

    try {
      let operation = await getAI().models.generateVideos({
        model,
        prompt: `${prompt}. Make this image come alive for 5 seconds. Add subtle motion, like blinking or a gentle smile, while maintaining the character's look.`,
        image: {
          imageBytes: base64ImageData,
          mimeType: mimeType,
        },
        config: {
          numberOfVideos: 1,
        },
      });

      console.log('Video operation started:', operation);

      while (!operation.done) {
        console.log('Polling for video result...');
        await new Promise(resolve => setTimeout(resolve, 10000));
        operation = await getAI().operations.getVideosOperation({
          operation: operation,
        });
        console.log('Polling response:', operation);
      }

      if (operation.error) {
        const errorMessage =
          typeof operation.error.message === 'string'
            ? operation.error.message
            : 'Video generation failed';
        throw new Error(errorMessage);
      }

      const downloadLink = operation.response?.generatedVideos?.[0]?.video?.uri;

      if (!downloadLink) {
        throw new Error('Video generation completed, but no download link was provided.');
      }

      console.log('Video generated, download link:', downloadLink);

      const apiKey = (import.meta as any).env?.VITE_GEMINI_API_KEY || '';
      const response = await fetch(`${downloadLink}&key=${apiKey}`);
      if (!response.ok) {
        throw new Error(`Failed to download video file: ${response.statusText}`);
      }

      const videoBlob = await response.blob();
      const videoUrl = URL.createObjectURL(videoBlob);

      console.log('Video downloaded and blob URL created:', videoUrl);
      return videoUrl;
    } catch (error) {
      lastError = error;
      console.error(`‚ùå Video model ${model} failed:`, error);
    }
  }

  console.error('‚ùå All video models failed');
  throw lastError instanceof Error
    ? lastError
    : new Error('All video models failed.');
}
